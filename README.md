# Cobol Copybook JSONifier

[CHANGELOG.md](CHANGELOG.md)

---

## Straight to the point

Take a look at [pypi.org](https://pypi.org/project/coboljsonifier/)

``` bash
pip install coboljsonifier
```

**example.py**

``` python
import simplejson
from coboljsonifier.copybookextractor import CopybookExtractor
from coboljsonifier.parser import Parser
from coboljsonifier.config.parser_type_enum import ParseType

bookname='DATA1.cob'

# extracts book structure
dict_structure = CopybookExtractor(fname).dict_book_structure

# uses book structure to build a parser
parser = Parser(dict_structure, ParseType.FLAT_ASCII).parser
size = parser.size
print("Record lenght:", size)

dataname = "DATA.txt"

''' Important! 
    EBCDIC files open the file with "rb" "read binary" and reads 
           it by size f2.read(size) - EBCDIC files generally doesn't have end-line character
    ASCII files open the file with r  "read text" and reads it by lines - f2.readline()
'''
i = 0
with open(fname2, 'r') as f2:
    while True:
        #EBCDIC
        # data = f2.read(size)

        # ASCII
        data = f2.readline()
        if not data:
            break
        i += 1
        parser.parse(data)
        print(simplejson.dumps(parser.value, indent=2))

print(f"Total processed: {i}")
```

---
## What is that for?

The main idea is to convert files from Mainframe that was generated by Cobol Programs that use Cobol-Copybooks.

Cobol copybooks are like data schemas for raw positional data.

To use the package you need:
1. Extract a cobol copybook structure to generate a python dictionary. This dictionary contains objects neededs to build the parser.

2. Build a Parser based on the previous copybook struture extracted.The parser contains python objects that will handle each kind of data field in the Mainframe's file. That file could be eater EBCDI or ASCII.
    > **Note:**  
    > For ASCII it doesn't support types such as: `Binary`, `COMP3`, `Signed` etc.  
    > Just suports formats like `PIC 9(n)`, `PIC X(n)` and Masked `PIC +99999.99`. These are formats that could be converted in the transfer process like FTP, Connect Dirct etc from mainframe to another platform.

-----

## Pre-requisites

* To save in json formats is necessary to use <spam style="color:#009900">`simplejson`</spam> package. It's to keep compatibility of `Decimal` pakage that is used to handle monetary values.
* The common `json` library has incompatibility with Decimal values

* Install `simplejson` just running `pip install simplejson`.
* Use `simplejson` the same way of `json`. 
    > Ex.   
    > `install simplejson as json`   
    > It will keep compatibility with the main functionalities.

-----

## Local environment

```bash
$ python -m venv venv
$ source venv/bin/activate
$ pip install -r requirements.txt

```

## Testing

**Undestanding the use with:** `'parser_tester.py'`

``` bash
$ python parser_tester.py
```

**Unit Tests:**
``` bash
# Running only the unittest
$ python -m unittest discover

# Checking test coveraging
$ coverage run -m unittest discover
$ coverage report -m
$ coverage html
```


**Cobol Copybook Example**

``` cobol 
COPY DT00RL
002200 01 :DT00:-RECORD.                                 
002300    03 :DT00:-KEY.                                
002400       05 :DT00:-ORG-ACCT.                       
002500           07 :DT00:-ORG  PIC 999.               
002600           07 :DT00:-ACCT PIC X(19).             
002700       05  :DT00:-STMT-ID-CODE                    
002800                           PIC S9(7)  BINARY.

```

## References

* [Python Packaging Projects](https://packaging.python.org/tutorials/packaging-projects/)

* [Where to put tests](http://pythonchb.github.io/PythonTopics/where_to_put_tests.html)

* [Python Modules](https://docs.python.org/3/tutorial/modules.html)

* [Absolute vs Relative python imports](https://realpython.com/absolute-vs-relative-python-imports/)

* [Python UnitTest](https://pythontesting.net/framework/specify-test-unittest-nosetests-pytest/)